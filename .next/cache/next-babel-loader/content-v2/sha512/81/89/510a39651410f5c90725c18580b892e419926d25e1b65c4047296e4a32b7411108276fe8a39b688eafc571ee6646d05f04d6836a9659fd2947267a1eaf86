{"ast":null,"code":"import _defineProperty from \"/Users/t/Documents_2/Work/Qiekub/code/umami/umami/node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _slicedToArray from \"/Users/t/Documents_2/Work/Qiekub/code/umami/umami/node_modules/next/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _inherits from \"/Users/t/Documents_2/Work/Qiekub/code/umami/umami/node_modules/next/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"/Users/t/Documents_2/Work/Qiekub/code/umami/umami/node_modules/next/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/t/Documents_2/Work/Qiekub/code/umami/umami/node_modules/next/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _wrapNativeSuper from \"/Users/t/Documents_2/Work/Qiekub/code/umami/umami/node_modules/next/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _wrapRegExp(re, groups) { _wrapRegExp = function _wrapRegExp(re, groups) { return new BabelRegExp(re, undefined, groups); }; var _RegExp = _wrapNativeSuper(RegExp); var _super = RegExp.prototype; var _groups = new WeakMap(); function BabelRegExp(re, flags, groups) { var _this = _RegExp.call(this, re, flags); _groups.set(_this, groups || _groups.get(re)); return _this; } _inherits(BabelRegExp, _RegExp); BabelRegExp.prototype.exec = function (str) { var result = _super.exec.call(this, str); if (result) result.groups = buildGroups(result, this); return result; }; BabelRegExp.prototype[Symbol.replace] = function (str, substitution) { if (typeof substitution === \"string\") { var groups = _groups.get(this); return _super[Symbol.replace].call(this, str, substitution.replace(/\\$<([^>]+)>/g, function (_, name) { return \"$\" + groups[name]; })); } else if (typeof substitution === \"function\") { var _this = this; return _super[Symbol.replace].call(this, str, function () { var args = []; args.push.apply(args, arguments); if (typeof args[args.length - 1] !== \"object\") { args.push(buildGroups(args, _this)); } return substitution.apply(this, args); }); } else { return _super[Symbol.replace].call(this, str, substitution); } }; function buildGroups(result, re) { var g = _groups.get(re); return Object.keys(g).reduce(function (groups, name) { groups[name] = result[g[name]]; return groups; }, Object.create(null)); } return _wrapRegExp.apply(this, arguments); }\n\nimport moment from 'moment-timezone';\nimport { addMinutes, addHours, addDays, addMonths, addYears, subHours, subDays, startOfMinute, startOfHour, startOfDay, startOfWeek, startOfMonth, startOfYear, endOfHour, endOfDay, endOfWeek, endOfMonth, endOfYear, differenceInMinutes, differenceInHours, differenceInCalendarDays, differenceInCalendarMonths, differenceInCalendarYears, format } from 'date-fns';\nimport { enUS } from 'date-fns/locale';\nimport { dateLocales } from 'lib/lang';\nexport function getTimezone() {\n  return moment.tz.guess();\n}\nexport function getLocalTime(t) {\n  return addMinutes(new Date(t), new Date().getTimezoneOffset());\n}\nexport function getDateRange(value) {\n  var locale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'en-US';\n  var now = new Date();\n  var localeOptions = dateLocales[locale];\n  var _value$match$groups = value.match( /*#__PURE__*/_wrapRegExp(/^([0-9]+)(hour|day|week|month|year)$/, {\n    num: 1,\n    unit: 2\n  })).groups,\n      num = _value$match$groups.num,\n      unit = _value$match$groups.unit;\n\n  if (+num === 1) {\n    switch (unit) {\n      case 'day':\n        return {\n          startDate: startOfDay(now),\n          endDate: endOfDay(now),\n          unit: 'hour',\n          value: value\n        };\n\n      case 'week':\n        return {\n          startDate: startOfWeek(now, {\n            locale: localeOptions\n          }),\n          endDate: endOfWeek(now, {\n            locale: localeOptions\n          }),\n          unit: 'day',\n          value: value\n        };\n\n      case 'month':\n        return {\n          startDate: startOfMonth(now),\n          endDate: endOfMonth(now),\n          unit: 'day',\n          value: value\n        };\n\n      case 'year':\n        return {\n          startDate: startOfYear(now),\n          endDate: endOfYear(now),\n          unit: 'month',\n          value: value\n        };\n    }\n  }\n\n  switch (unit) {\n    case 'day':\n      return {\n        startDate: subDays(startOfDay(now), num - 1),\n        endDate: endOfDay(now),\n        unit: unit,\n        value: value\n      };\n\n    case 'hour':\n      return {\n        startDate: subHours(startOfHour(now), num - 1),\n        endDate: endOfHour(now),\n        unit: unit,\n        value: value\n      };\n  }\n}\nexport function getDateRangeValues(startDate, endDate) {\n  var unit = 'year';\n\n  if (differenceInHours(endDate, startDate) <= 48) {\n    unit = 'hour';\n  } else if (differenceInCalendarDays(endDate, startDate) <= 90) {\n    unit = 'day';\n  } else if (differenceInCalendarMonths(endDate, startDate) <= 24) {\n    unit = 'month';\n  }\n\n  return {\n    startDate: startOfDay(startDate),\n    endDate: endOfDay(endDate),\n    unit: unit\n  };\n}\nexport function getDateFromString(str) {\n  var _str$split = str.split(' '),\n      _str$split2 = _slicedToArray(_str$split, 2),\n      ymd = _str$split2[0],\n      hms = _str$split2[1];\n\n  var _ymd$split = ymd.split('-'),\n      _ymd$split2 = _slicedToArray(_ymd$split, 3),\n      year = _ymd$split2[0],\n      month = _ymd$split2[1],\n      day = _ymd$split2[2];\n\n  if (hms) {\n    var _hms$split = hms.split(':'),\n        _hms$split2 = _slicedToArray(_hms$split, 3),\n        hour = _hms$split2[0],\n        min = _hms$split2[1],\n        sec = _hms$split2[2];\n\n    return new Date(year, month - 1, day, hour, min, sec);\n  }\n\n  return new Date(year, month - 1, day);\n}\nvar dateFuncs = {\n  minute: [differenceInMinutes, addMinutes, startOfMinute],\n  hour: [differenceInHours, addHours, startOfHour],\n  day: [differenceInCalendarDays, addDays, startOfDay],\n  month: [differenceInCalendarMonths, addMonths, startOfMonth],\n  year: [differenceInCalendarYears, addYears, startOfYear]\n};\nexport function getDateArray(data, startDate, endDate, unit) {\n  var arr = [];\n\n  var _dateFuncs$unit = _slicedToArray(dateFuncs[unit], 3),\n      diff = _dateFuncs$unit[0],\n      add = _dateFuncs$unit[1],\n      normalize = _dateFuncs$unit[2];\n\n  var n = diff(endDate, startDate) + 1;\n\n  function findData(t) {\n    var x = data.find(function (e) {\n      return normalize(getDateFromString(e.t)).getTime() === t.getTime();\n    });\n    return (x === null || x === void 0 ? void 0 : x.y) || 0;\n  }\n\n  for (var i = 0; i < n; i++) {\n    var t = normalize(add(startDate, i));\n    var y = findData(t);\n    arr.push(_objectSpread(_objectSpread({}, data[i]), {}, {\n      t: t,\n      y: y\n    }));\n  }\n\n  return arr;\n}\nexport function getDateLength(startDate, endDate, unit) {\n  var _dateFuncs$unit2 = _slicedToArray(dateFuncs[unit], 1),\n      diff = _dateFuncs$unit2[0];\n\n  return diff(endDate, startDate) + 1;\n}\nexport var customFormats = {\n  'en-US': {\n    p: 'ha',\n    pp: 'h:mm:ss'\n  }\n};\nexport function dateFormat(date, str) {\n  var _customFormats$locale;\n\n  var locale = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'en-US';\n  return format(date, (customFormats === null || customFormats === void 0 ? void 0 : (_customFormats$locale = customFormats[locale]) === null || _customFormats$locale === void 0 ? void 0 : _customFormats$locale[str]) || str, {\n    locale: dateLocales[locale] || enUS\n  });\n}","map":null,"metadata":{},"sourceType":"module"}